================================================================================
LETTER GLITCH & WELCOME SCREEN / BOOT SCREEN - COMPLETE SETUP GUIDE
================================================================================

This document provides a comprehensive overview of how the letter glitch effect,
welcome screen, and boot screen are implemented in the Omega Terminal application.
Use this guide to recreate these features in a new application.

================================================================================
TABLE OF CONTENTS
================================================================================

1. OVERVIEW
2. LETTER GLITCH COMPONENT
3. WELCOME SCREEN COMPONENT
4. BOOT ANIMATION COMPONENT
5. INTEGRATION & FLOW
6. FILE STRUCTURE
7. DEPENDENCIES
8. KEY FEATURES BREAKDOWN
9. RECREATION STEPS

================================================================================
1. OVERVIEW
================================================================================

The system consists of three main components:

A. LetterGlitch Component
   - Canvas-based animated background with random characters
   - Multiple glitch effects (intense, hover)
   - Hidden text easter eggs (clickable words)
   - Vortex/black hole effect in center
   - Vignette overlays (center and outer)
   - Smooth color transitions
   - Interactive click detection

B. WelcomeScreen Component
   - Full-screen interface selector
   - Uses LetterGlitch as background
   - Loading animation with progress bar
   - Mode selection (Basic Terminal / Dashboard)
   - Dynamic color palette system
   - Sparkling Christmas color theme
   - Hover/click interactions that trigger glitch effects

C. BootAnimation Component
   - Initial load animation
   - Omega logo with glow effect
   - Progress bar animation
   - Feature badges display
   - Auto-completes after duration

================================================================================
2. LETTER GLITCH COMPONENT
================================================================================

FILE: src/components/Dashboard/LetterGlitch.tsx

CORE CONCEPTS:
--------------
- Uses HTML5 Canvas for rendering
- Grid-based letter system (columns x rows)
- RequestAnimationFrame for smooth animation
- Multiple animation states (normal, glitching, hover glitch)
- Hidden text easter egg system with click detection

PROPS:
------
- glitchColors: string[] - Array of hex colors for letters (default: ['#2b4539', '#61dca3', '#61b3dc'])
- glitchSpeed: number - Milliseconds between letter updates (default: 50)
- centerVignette: boolean - Show black shader over center (default: true)
- outerVignette: boolean - Show outer vignette (default: true)
- smooth: boolean - Enable smooth color transitions (default: true)
- characters: string - Character set to use (default: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$&*()-_+=/[]{};:<>.,0123456789Ω')

REF METHODS (via forwardRef):
------------------------------
- triggerIntenseGlitch(colors?, duration?) - Rapid scramble all letters
- triggerHoverGlitch(colors?, duration?) - Slow separation effect
- stopHoverGlitch() - Return to normal from hover glitch
- scrambleAll(colors?) - Scramble all letters at once
- resetToNormal() - Reset to default state

INTERNAL STRUCTURE:
-------------------

1. CANVAS SETUP
   - Creates canvas element that fills container
   - Handles device pixel ratio for retina displays
   - Calculates grid dimensions based on character size
   - Character dimensions: width=10px, height=20px, fontSize=16px

2. LETTER GRID SYSTEM
   - Each letter is stored in letters.current array
   - Letter object structure:
     {
       char: string,              // Current character
       color: string,              // Current RGB color
       targetColor: string,        // Target color for transition
       colorProgress: number,      // 0-1 transition progress
       offsetX: number,            // X offset for hover glitch
       offsetY: number,            // Y offset for hover glitch
       targetOffsetX: number,      // Target X offset
       targetOffsetY: number,      // Target Y offset
       offsetProgress: number,     // Offset transition progress
       isFrozen: boolean,          // True if part of found hidden word
       frozenText?: string          // Word this letter belongs to
     }

3. ANIMATION LOOP
   - Uses requestAnimationFrame for 60fps animation
   - Main animate() function:
     a. Updates random letters periodically (based on glitchSpeed)
     b. Handles smooth color transitions
     c. Handles smooth position transitions (hover glitch)
     d. Redraws canvas with drawLetters()
   - Updates 5% of letters per cycle in normal mode
   - Faster updates during intense glitch (30% per cycle, every 20ms)

4. DRAWING SYSTEM
   - drawLetters() renders all letters to canvas
   - Two-pass rendering:
     a. First pass: Non-frozen letters (affected by vortex)
     b. Second pass: Frozen letters (always visible, no vortex)
   - Applies vortex effect to non-frozen letters:
     - Calculates distance from center
     - Pulls letters toward center (black hole effect)
     - Fades and shrinks letters as they approach center
     - Stronger pull in inner 30% of screen
   - Frozen letters have glow effect (shadowBlur: 8)

5. GLITCH EFFECTS

   A. INTENSE GLITCH (triggerIntenseGlitch)
      - Scrambles ALL letters immediately
      - Rapid updates (every 20ms)
      - Updates 30% of letters per cycle
      - Duration: 300ms default
      - Uses provided colors or original palette
      - After completion: reorganizes letters back to normal

   B. HOVER GLITCH (triggerHoverGlitch)
      - Slow, gradual separation effect
      - Letters move outward from center
      - Random separation direction (2-6 character widths)
      - Slower updates (every 150ms)
      - Updates 2% of letters per cycle
      - Duration: 800ms default
      - Smooth return to normal when stopped

   C. SMOOTH TRANSITIONS
      - Color transitions: 0.05 increment per frame (20 frames to complete)
      - Position transitions: 0.02 increment per frame (50 frames to complete)
      - Uses interpolateColor() for RGB interpolation

6. VORTEX / BLACK HOLE EFFECT
   - Active in center 50% of screen
   - Strong pull in inner 30%
   - Exponential falloff: Math.pow(1 - (normalizedDistance / 0.5), 2)
   - Max pull: 1.2 character widths
   - Adds slight rotation for spiral effect
   - Letters fade (up to 50% opacity) and shrink (up to 30%) as pulled in

7. VIGNETTE OVERLAYS
   - Center vignette: Radial gradient creating black hole shader
     - rgba(0,0,0,0.85) at center
     - Fades to transparent at 80% radius
     - z-index: 3
     - Has vortexPulse animation (4s infinite)
   
   - Outer vignette: Radial gradient darkening edges
     - Transparent at 75% radius
     - rgba(0,0,0,0.6) at edges
     - z-index: 2

8. HIDDEN TEXT EASTER EGG SYSTEM
   - Words defined in: src/lib/letterGlitchWords.ts
   - Current words: ["OMEGA", "DeFi", "Web3", "ETH", "BTC", "SOL"]
   - Randomly displays words every 4-8 seconds
   - Words appear in bright magenta (#ff00ff) with pulsing effect
   - Words placed outside black hole zone (center 50%)
   - Display duration: 5-8 seconds (random)
   - Click detection:
     - Generous padding (2x char width/height) around words
     - Handles mouse clicks, mousedown, and touch events
     - Shows pointer cursor when hovering over word
   - When clicked/frozen:
     - Animates to bright green (#00ff88)
     - Freezes letters (isFrozen: true)
     - Records word via API: POST /api/letter-glitch/words
     - Stores in localStorage via wallet address
   - Bottom overlay shows:
     - Progress: X/6 found
     - List of all words with status (found/active/normal)
     - Active word is clickable and pulsing
     - Connect wallet hint if not connected

9. COLOR SYSTEM
   - Default colors: ['#2b4539', '#61dca3', '#61b3dc']
   - Colors can be changed via props
   - Original colors stored in originalGlitchColors ref
   - Color transitions use RGB interpolation
   - Hidden words use special colors:
     - Active: #ff00ff (bright magenta)
     - Found: #00ff88 (bright green)

10. RESPONSIVE HANDLING
    - Resize observer handles window resizing
    - Recalculates grid on resize
    - Debounced resize handler (100ms timeout)
    - Maintains aspect ratio with device pixel ratio

11. EVENT HANDLERS
    - Canvas click: Freezes active hidden word
    - Canvas mousedown: Backup click handler
    - Canvas touchstart: Mobile touch support
    - Canvas mousemove: Updates cursor (pointer over words)
    - selectstart: Prevents text selection
    - All events have preventDefault/stopPropagation

12. CLEANUP
    - Cancels animation frames
    - Clears all intervals and timeouts
    - Removes event listeners
    - Proper cleanup in useEffect return

================================================================================
3. WELCOME SCREEN COMPONENT
================================================================================

FILE: src/components/Dashboard/WelcomeScreen.tsx
STYLES: src/components/Dashboard/WelcomeScreen.module.css

CORE CONCEPTS:
--------------
- Full-screen overlay (z-index: 99999)
- Uses LetterGlitch as animated background
- Loading animation with progress tracking
- Interface mode selector (Basic Terminal / Dashboard)
- Dynamic color palette system
- Sparkling Christmas color theme
- Interactive hover/click effects

PROPS:
------
- onComplete: () => void - Callback when user selects mode
- initialMode?: ViewMode - Initial selected mode ("basic" | "futuristic")

STATE MANAGEMENT:
-----------------

1. LOADING STATE
   - progress: 0-100 (loading progress)
   - currentStep: 0-5 (current loading step index)
   - isReady: boolean (when loading completes)
   - exiting: boolean (exit animation state)

2. MODE SELECTION
   - selectedMode: ViewMode ("basic" | "futuristic")
   - isMobile: boolean (detected from user agent and width)

3. COLOR SYSTEM
   - temporaryPalette: string[] | null (temporary colors for glitch)
   - sparkleColors: string[] (sparkling xmas colors)
   - paletteUpdateKey: number (force recalculation)

LOADING ANIMATION:
------------------
- Duration: 3000ms (3 seconds)
- Steps array:
  1. "Initializing Omega Terminal"
  2. "Loading blockchain providers"
  3. "Setting up interface"
  4. "Preparing media modules"
  5. "Syncing data"
  6. "Finalizing"
- Uses requestAnimationFrame for smooth progress
- Progress bar uses transform: scaleX() for performance
- Shows current step text during loading

COLOR PALETTE SYSTEM:
---------------------

1. SPARKLING XMAS COLORS
   - Base colors: Red (#dc143c), Green (#228b22), White (#ffffff)
   - Generates 12-18 color variations with brightness variations
   - Brightness range: 0.4 (dim) to 1.4 (bright)
   - Updates every 1500-2200ms for sparkling effect
   - Uses sine wave pattern for smooth transitions
   - generateSparkleColor() function creates variations

2. SECTION PALETTES
   - header: ['#4a6fa5', '#6b8fc7', '#7ba3d9', '#4a6fa5'] (Midnight Blue)
   - basic: ['#ffffff', '#e0e0e0', '#c0c0c0', '#a0a0a0'] (White/Gray)
   - dashboard: ['#dc143c', '#228b22', '#ffffff', '#dc143c'] (Xmas)

3. CSS VARIABLE SYSTEM
   - Container has data-color-palette="xmas" attribute
   - CSS variables defined in WelcomeScreen.module.css
   - Variables: --palette-primary, --palette-secondary, --palette-accent, etc.
   - Includes glow effects: --palette-primary-glow, etc.

GLITCH INTERACTIONS:
--------------------

1. HOVER EFFECTS
   - Header hover: triggerHoverGlitch('header')
   - Basic button hover: triggerHoverGlitch('basic')
   - Dashboard button hover: triggerHoverGlitch('dashboard')
   - Uses section-specific color palettes
   - Duration: 1000ms
   - Stops on mouse leave

2. CLICK EFFECTS
   - Header click: triggerSectionGlitch('header', 500ms)
   - Basic button click: triggerSectionGlitch('basic', 400ms)
   - Dashboard button click: triggerSectionGlitch('dashboard', 400ms)
   - Intense glitch effect before mode selection
   - Resets palette after glitch completes

LAYOUT STRUCTURE:
-----------------

1. CONTAINER
   - position: fixed, inset: 0
   - background: rgba(0, 0, 0, 0.85)
   - z-index: 99999
   - flexbox column layout

2. LETTER GLITCH CONTAINER
   - position: absolute, inset: 0
   - z-index: 0
   - pointer-events: none (allows clicks through to buttons)
   - Contains LetterGlitch component

3. HEADER
   - Top bar with logo and version
   - background: rgba(0, 0, 0, 0.3)
   - backdrop-filter: blur(8px)
   - border-bottom: 1px solid rgba(255, 255, 255, 0.1)
   - z-index: 2
   - Interactive (hover/click triggers glitch)

4. MAIN CONTENT
   - Centered vertically and horizontally
   - flex: 1, display: flex, flex-direction: column
   - align-items: center, justify-content: center
   - z-index: 2

5. MAIN TEXT
   - Omega symbol (Ω): Large serif font
   - Main text: "OMEGA TERMINAL" (large, bold)
   - Subtitle: "Select your interface mode"
   - Shows loading steps when !isReady

6. ACTION BUTTONS
   - Two buttons: "Basic Terminal" and "Dashboard"
   - Styled with rounded corners (border-radius: 999px)
   - Active button has box-shadow outline
   - Dashboard disabled on mobile
   - Hover effects trigger glitch
   - Click triggers intense glitch then mode selection

7. PROGRESS INDICATOR
   - Shown only when !isReady
   - Progress bar with gradient fill
   - Uses transform: scaleX() for animation
   - Width: min(400px, 80vw)

MODE SELECTION FLOW:
-------------------
1. User clicks button
2. triggerSectionGlitch() called (intense glitch effect)
3. After 200ms delay: handleModeSelect() called
4. Sets selectedMode state
5. Saves to localStorage: "omega-view-mode"
6. After 500ms: setViewMode() called (context update)
7. setExiting(true) - starts exit animation
8. After 400ms: 
   - localStorage.setItem("omega-initialized", "true")
   - onComplete() called (hides welcome screen)

MOBILE HANDLING:
----------------
- Detects mobile via user agent and width <= 768px
- Auto-selects "basic" mode on mobile
- Disables "Dashboard" button on mobile
- Shows tooltip: "Dashboard is desktop-only"
- Responsive breakpoints in CSS:
  - @media (max-width: 768px)
  - @media (max-width: 480px)

PERSISTENCE:
------------
- Checks localStorage for "omega-initialized"
- If "true", welcome screen is skipped
- Saves "omega-view-mode" preference
- Welcome screen shows again if view mode changes

CSS ANIMATIONS:
---------------
- fadeIn: 0.5s ease-out (on mount)
- fadeOut: 0.4s ease-out (on exit)
- vortexPulse: 4s infinite (center vignette)

================================================================================
4. BOOT ANIMATION COMPONENT
================================================================================

FILE: src/components/Terminal/BootAnimation.tsx
STYLES: src/components/Terminal/BootAnimation.module.css

CORE CONCEPTS:
--------------
- Initial load animation before welcome screen
- Omega logo with glow effect
- Progress bar animation
- Feature badges display
- Auto-completes after duration

PROPS:
------
- onComplete: () => void - Callback when animation completes
- duration: number - Animation duration in ms (default: 2500ms from constants)

FEATURES:
---------

1. OMEGA LOGO
   - Large "Ω" symbol (120px on desktop)
   - Glow animation (2s infinite)
   - Text shadow with palette colors
   - Responsive sizing

2. TITLE & VERSION
   - "OMEGA TERMINAL" (48px, bold, letter-spacing: 4px)
   - Version number from APP_VERSION constant
   - Subtitle: "Multi-Chain Web3 Terminal"

3. PROGRESS BAR
   - Width: 400px (responsive)
   - Height: 4px
   - Gradient fill: primary to secondary color
   - Uses transform: scaleX() for animation
   - Glow effect with box-shadow

4. LOADING TEXT
   - "Initializing Terminal..."
   - Muted color
   - Updates with progress

5. FEATURE BADGES
   - 5 badges with SVG icons:
     * AI (robot icon)
     * Multi-Chain (blockchain icon)
     * Productivity (clock icon)
     * Security (lock icon)
     * Themes (palette icon)
   - Hover effects with glow
   - Responsive grid layout

ANIMATION:
----------
- Uses requestAnimationFrame
- Progress: 0-100 over duration
- Smooth linear progression
- Calls onComplete() when progress reaches 100%

STYLING:
--------
- Full viewport (100vw x 100vh)
- Centered content
- Gradient background
- CSS variables for theming
- Responsive breakpoints:
  - @media (max-width: 1400px)
  - @media (max-width: 1024px)
  - @media (max-width: 768px)
  - @media (max-width: 480px)

CONSTANTS:
----------
- BOOT_ANIMATION_DURATION: 2500ms (from src/lib/constants.ts)
- APP_VERSION: Version string (from src/lib/constants.ts)

================================================================================
5. INTEGRATION & FLOW
================================================================================

FILE: src/app/page.tsx

COMPLETE FLOW:
--------------

1. INITIAL LOAD
   - Component mounts
   - Checks localStorage for "omega-initialized"
   - If not initialized:
     a. Shows WelcomeScreen
     b. WelcomeScreen shows loading animation (3s)
     c. User selects mode
     d. Sets "omega-initialized" = "true"
     e. Shows main interface

2. SUBSEQUENT LOADS
   - Checks localStorage
   - If "omega-initialized" === "true":
     - Skips WelcomeScreen
     - Shows main interface directly

3. VIEW MODE CHANGES
   - Detects view mode change
   - Shows WelcomeScreen again
   - User can select new mode
   - Updates localStorage

4. MOUNTING & HYDRATION
   - Uses mounted state to prevent hydration mismatch
   - Shows DashboardLoadingSkeleton while mounting
   - Only renders after mount and terminalModeHydrated

CODE STRUCTURE:
---------------

```typescript
function HomePageContent() {
  const [mounted, setMounted] = useState(false);
  const [showWelcome, setShowWelcome] = useState(true);
  
  useEffect(() => {
    setMounted(true);
    const initialized = localStorage.getItem("omega-initialized");
    if (initialized === "true") {
      setShowWelcome(false);
    }
  }, []);
  
  // Show welcome on view mode change
  useEffect(() => {
    // ... view mode change detection
  }, [viewMode, mounted]);
  
  if (!mounted || !terminalModeHydrated) {
    return <DashboardLoadingSkeleton />;
  }
  
  if (showWelcome) {
    return <WelcomeScreen onComplete={handleWelcomeComplete} initialMode={viewMode} />;
  }
  
  // ... render main interface
}
```

================================================================================
6. FILE STRUCTURE
================================================================================

REQUIRED FILES:
---------------

Components:
- src/components/Dashboard/LetterGlitch.tsx
- src/components/Dashboard/WelcomeScreen.tsx
- src/components/Dashboard/WelcomeScreen.module.css
- src/components/Terminal/BootAnimation.tsx
- src/components/Terminal/BootAnimation.module.css

Utilities:
- src/lib/letterGlitchWords.ts (word definitions)
- src/lib/constants.ts (APP_VERSION, BOOT_ANIMATION_DURATION)

Integration:
- src/app/page.tsx (main page integration)

Hooks (if using):
- src/hooks/useViewMode.ts (view mode context)
- src/hooks/useCustomizer.ts (color palette context)
- src/hooks/useWallet.ts (wallet connection for hidden words)

API Routes (for hidden words feature):
- src/app/api/letter-glitch/words/route.ts (GET/POST endpoints)

Types:
- src/types/ui.ts (ViewMode type)
- src/types/terminal.ts (BootAnimationProps)

================================================================================
7. DEPENDENCIES
================================================================================

REACT HOOKS:
------------
- useState
- useEffect
- useRef
- useMemo
- useCallback
- useImperativeHandle
- forwardRef

CONTEXT PROVIDERS (if using):
------------------------------
- ViewModeProvider (for view mode state)
- CustomizerProvider (for color palette)
- WalletProvider (for wallet connection)

CSS FEATURES:
-------------
- CSS Modules (for scoped styles)
- CSS Variables (for theming)
- backdrop-filter (for blur effects)
- transform (for animations)
- @keyframes (for animations)

BROWSER APIs:
-------------
- Canvas API (for letter rendering)
- requestAnimationFrame (for animation loop)
- localStorage (for persistence)
- getComputedStyle (for CSS variable reading)
- MutationObserver (for palette change detection)

================================================================================
8. KEY FEATURES BREAKDOWN
================================================================================

A. LETTER GLITCH ANIMATION
   - Canvas-based rendering for performance
   - Grid system for letter positioning
   - Smooth color transitions
   - Multiple glitch modes
   - Vortex/black hole effect
   - Vignette overlays
   - Hidden text easter eggs
   - Click detection
   - Responsive resizing

B. WELCOME SCREEN
   - Full-screen overlay
   - Loading animation
   - Progress tracking
   - Mode selection
   - Dynamic color system
   - Sparkling color effects
   - Interactive glitch triggers
   - Mobile detection
   - Persistence

C. BOOT ANIMATION
   - Logo animation
   - Progress bar
   - Feature badges
   - Auto-complete
   - Responsive design

D. INTEGRATION
   - localStorage persistence
   - Conditional rendering
   - Hydration handling
   - View mode detection

================================================================================
9. RECREATION STEPS
================================================================================

STEP 1: SET UP BASE STRUCTURE
-------------------------------
1. Create component directories:
   - components/Dashboard/
   - components/Terminal/

2. Create utility files:
   - lib/letterGlitchWords.ts
   - lib/constants.ts

3. Set up types:
   - types/ui.ts
   - types/terminal.ts

STEP 2: IMPLEMENT LETTER GLITCH
--------------------------------
1. Create LetterGlitch.tsx component
2. Set up canvas element and context
3. Implement grid calculation
4. Implement letter initialization
5. Implement drawLetters() function
6. Implement animation loop with requestAnimationFrame
7. Implement updateLetters() for random updates
8. Implement smooth color transitions
9. Implement vortex effect
10. Implement vignette overlays
11. Implement glitch effects (intense, hover)
12. Implement hidden text system
13. Implement click detection
14. Add cleanup in useEffect

STEP 3: IMPLEMENT WELCOME SCREEN
---------------------------------
1. Create WelcomeScreen.tsx component
2. Create WelcomeScreen.module.css
3. Set up state management (progress, isReady, etc.)
4. Implement loading animation
5. Integrate LetterGlitch component
6. Implement color palette system
7. Implement sparkling color generation
8. Implement hover/click glitch triggers
9. Implement mode selection UI
10. Implement mobile detection
11. Add CSS animations
12. Implement persistence

STEP 4: IMPLEMENT BOOT ANIMATION
---------------------------------
1. Create BootAnimation.tsx component
2. Create BootAnimation.module.css
3. Implement progress animation
4. Add logo, title, version
5. Add progress bar
6. Add feature badges
7. Implement onComplete callback
8. Add responsive styles

STEP 5: INTEGRATE IN MAIN PAGE
-------------------------------
1. Import components in page.tsx
2. Set up state for showWelcome
3. Implement localStorage checks
4. Implement view mode change detection
5. Add conditional rendering
6. Handle hydration

STEP 6: ADD API ROUTES (OPTIONAL)
----------------------------------
1. Create /api/letter-glitch/words/route.ts
2. Implement GET endpoint (fetch found words)
3. Implement POST endpoint (save found word)
4. Add database/storage if needed

STEP 7: TESTING
---------------
1. Test initial load (shows welcome screen)
2. Test mode selection
3. Test persistence (refresh page)
4. Test view mode changes
5. Test mobile detection
6. Test glitch effects
7. Test hidden text easter eggs
8. Test click detection
9. Test responsive design

STEP 8: OPTIMIZATION
--------------------
1. Optimize canvas rendering
2. Debounce resize handlers
3. Memoize expensive calculations
4. Use CSS transforms for animations
5. Lazy load components if needed
6. Optimize color calculations

================================================================================
10. DETAILED CODE PATTERNS
================================================================================

CANVAS SETUP PATTERN:
---------------------
```typescript
const canvasRef = useRef<HTMLCanvasElement | null>(null);
const context = useRef<CanvasRenderingContext2D | null>(null);

useEffect(() => {
  const canvas = canvasRef.current;
  if (!canvas) return;
  
  context.current = canvas.getContext('2d');
  
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.parentElement.getBoundingClientRect();
  
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  canvas.style.width = `${rect.width}px`;
  canvas.style.height = `${rect.height}px`;
  
  if (context.current) {
    context.current.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
}, []);
```

ANIMATION LOOP PATTERN:
-----------------------
```typescript
const animationRef = useRef<number | null>(null);

const animate = () => {
  // Update logic
  updateLetters();
  drawLetters();
  
  animationRef.current = requestAnimationFrame(animate);
};

useEffect(() => {
  animate();
  
  return () => {
    if (animationRef.current) {
      cancelAnimationFrame(animationRef.current);
    }
  };
}, []);
```

COLOR INTERPOLATION PATTERN:
----------------------------
```typescript
const hexToRgb = (hex: string) => {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16)
  } : null;
};

const interpolateColor = (start: RGB, end: RGB, factor: number) => {
  return `rgb(${Math.round(start.r + (end.r - start.r) * factor)}, 
              ${Math.round(start.g + (end.g - start.g) * factor)}, 
              ${Math.round(start.b + (end.b - start.b) * factor)})`;
};
```

SMOOTH TRANSITION PATTERN:
--------------------------
```typescript
const handleSmoothTransitions = () => {
  let needsRedraw = false;
  
  letters.current.forEach(letter => {
    if (letter.colorProgress < 1) {
      letter.colorProgress += 0.05;
      if (letter.colorProgress > 1) letter.colorProgress = 1;
      
      const startRgb = hexToRgb(letter.color);
      const endRgb = hexToRgb(letter.targetColor);
      if (startRgb && endRgb) {
        letter.color = interpolateColor(startRgb, endRgb, letter.colorProgress);
        needsRedraw = true;
      }
    }
  });
  
  if (needsRedraw) {
    drawLetters();
  }
};
```

VORTEX EFFECT PATTERN:
---------------------
```typescript
const centerX = width / 2;
const centerY = height / 2;
const dx = baseX - centerX;
const dy = baseY - centerY;
const distance = Math.sqrt(dx * dx + dy * dy);
const maxDistance = Math.sqrt(centerX * centerX + centerY * centerY);
const normalizedDistance = distance / maxDistance;

const vortexStrength = normalizedDistance < 0.5 
  ? Math.pow(1 - (normalizedDistance / 0.5), 2)
  : 0;

const vortexPull = vortexStrength * 1.2;
const angle = Math.atan2(dy, dx);
const rotation = normalizedDistance * 0.3;

const vortexX = -Math.cos(angle + rotation) * vortexPull * charWidth;
const vortexY = -Math.sin(angle + rotation) * vortexPull * charHeight;
```

PROGRESS ANIMATION PATTERN:
---------------------------
```typescript
useEffect(() => {
  let animationFrameId: number;
  let startTime: number | null = null;
  const duration = 3000;
  
  const animate = (timestamp: number) => {
    if (startTime === null) {
      startTime = timestamp;
    }
    
    const elapsed = timestamp - startTime;
    const progressValue = Math.min(100, (elapsed / duration) * 100);
    
    setProgress(progressValue);
    
    if (progressValue < 100) {
      animationFrameId = requestAnimationFrame(animate);
    } else {
      setIsReady(true);
    }
  };
  
  animationFrameId = requestAnimationFrame(animate);
  
  return () => {
    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId);
    }
  };
}, []);
```

CLICK DETECTION PATTERN:
------------------------
```typescript
const handleCanvasClick = (e: MouseEvent) => {
  e.preventDefault();
  e.stopPropagation();
  
  const canvas = canvasRef.current;
  if (!canvas) return;
  
  const rect = canvas.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;
  
  // Check bounds with padding
  const paddingX = charWidth * 2.0;
  const paddingY = charHeight * 2.0;
  
  const textStartX = (startCol * charWidth) - paddingX;
  const textEndX = ((startCol + length) * charWidth) + paddingX;
  const textY = (startRow * charHeight) - paddingY;
  const textEndY = ((startRow + 1) * charHeight) + paddingY;
  
  if (clickX >= textStartX && clickX <= textEndX && 
      clickY >= textY && clickY <= textEndY) {
    // Handle click
  }
};
```

================================================================================
11. PERFORMANCE CONSIDERATIONS
================================================================================

OPTIMIZATIONS:
--------------

1. CANVAS RENDERING
   - Use requestAnimationFrame (60fps)
   - Only redraw when needed (needsRedraw flag)
   - Use transform instead of width for progress bars
   - Clear canvas before redraw
   - Batch letter updates

2. MEMORY MANAGEMENT
   - Clean up all intervals/timeouts
   - Remove event listeners
   - Cancel animation frames
   - Use refs for values that don't need re-renders

3. CALCULATIONS
   - Memoize expensive calculations (useMemo)
   - Cache color conversions
   - Debounce resize handlers
   - Throttle update cycles

4. CSS PERFORMANCE
   - Use transform/opacity for animations
   - Use will-change for animated elements
   - Avoid layout thrashing
   - Use CSS variables for theming

5. REACT OPTIMIZATION
   - Use useCallback for event handlers
   - Use useMemo for computed values
   - Avoid unnecessary re-renders
   - Use refs for imperative handles

================================================================================
12. TROUBLESHOOTING
================================================================================

COMMON ISSUES:
--------------

1. Canvas not rendering
   - Check canvas ref is set
   - Check context is obtained
   - Check canvas dimensions are set
   - Check device pixel ratio handling

2. Animation not smooth
   - Check requestAnimationFrame is used
   - Check cleanup is proper
   - Check for memory leaks
   - Check browser performance

3. Colors not updating
   - Check color prop changes
   - Check useEffect dependencies
   - Check color interpolation logic
   - Check CSS variable reading

4. Click detection not working
   - Check event listeners are attached
   - Check pointer-events CSS
   - Check z-index stacking
   - Check coordinate calculations

5. Welcome screen not showing/hiding
   - Check localStorage values
   - Check mounted state
   - Check conditional rendering logic
   - Check onComplete callback

6. Mobile issues
   - Check mobile detection
   - Check touch event handlers
   - Check responsive CSS
   - Check viewport meta tag

================================================================================
END OF DOCUMENT
================================================================================

This document provides a complete overview of the letter glitch, welcome screen,
and boot screen implementation. Use this as a reference when recreating these
features in a new application.

For specific implementation details, refer to the source code files listed in
section 6 (File Structure).

